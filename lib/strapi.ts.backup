// Strapi REST API is used – GraphQL querying removed due to schema mismatch.
import qs from 'qs';
import { marked } from 'marked';
import { getCachedJson, getString, setString, getRedis } from './cache';

const STRAPI_URL = process.env.STRAPI_URL || process.env.NEXT_PUBLIC_CMS_URL;
const FULL_ARTICLE_ENDPOINT = '/api/articles/full';

if (!STRAPI_URL) {
  throw new Error('STRAPI_URL (or NEXT_PUBLIC_CMS_URL) env variable is not defined');
}

// Common headers for authenticated requests
const AUTH_HEADERS: Record<string, string> = process.env.STRAPI_TOKEN ? {
  Authorization: `Bearer ${process.env.STRAPI_TOKEN}`,
  'Content-Type': 'application/json',
} : { 'Content-Type': 'application/json' };

// ────────────────────────────
// GraphQL helper (Strapi Cloud has GraphQL plugin enabled by default)
// ────────────────────────────
async function queryStrapiGraphQL<T = any>(query: string, variables: Record<string, any> = {}): Promise<T> {
  const res = await fetch(`${STRAPI_URL}/graphql`, {
    method: 'POST',
    headers: AUTH_HEADERS,
    body: JSON.stringify({ query, variables }),
  });
  if (!res.ok) throw new Error(`Strapi GraphQL HTTP error ${res.status}`);
  const json = await res.json();
  if (json.errors?.length) {
    throw new Error(`Strapi GraphQL error: ${json.errors[0].message}`);
  }
  return json.data as T;
}


/*
 * Data transformers ───────────────────────────────────────────────────
 */

const toGhostLikeTag = (tag: any) => ({
  id: tag.id,
  name: tag.attributes?.name ?? tag.name,
  slug: tag.attributes?.slug ?? tag.slug,
});

const toGhostLikeAuthor = (author: any) => ({
  id: author?.id,
  name: author?.attributes?.name || author?.attributes?.username,
  slug: author?.attributes?.slug,
  profile_image: author?.attributes?.avatar?.data?.attributes?.url || null,
});

// helper to deduplicate posts array by slug, keeping latest publishedAt
const dedupeBySlug = (posts: any[]) => {
  const map = new Map<string, any>();
  posts.forEach(p => {
    const existing = map.get(p.slug);
    if (!existing) map.set(p.slug, p);
    else {
      const existingDate = new Date(existing.published_at || existing.publishedAt || 0).getTime();
      const newDate = new Date(p.published_at || p.publishedAt || 0).getTime();
      if (newDate >= existingDate) map.set(p.slug, p);
    }
  });
  return Array.from(map.values());
};

export const toGhostLikePost = (item: any) => {
  // Strapi may return nested {attributes} or flat fields depending on response style
  const id = item.id;
  const attrs = item.attributes ?? item;
  // simple slugify fallback (lowercase, replace spaces/invalid chars with hyphens)
  const ensureSlug = (value: string) => value
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '') // keep alphanum, space, dash
    .replace(/\s+/g, '-')         // spaces -> dash
    .replace(/-+/g, '-')           // collapse multiple dashes
    .replace(/^-+|-+$/g, '');      // trim leading/trailing dashes

  // Robustly derive slug. Fallback to `post-<id>` when every option yields an empty slug.
  const derivedSlug = (() => {
    const candidates = [attrs.slug, attrs.uid, attrs.title].filter(Boolean);
    for (const cand of candidates) {
      const slugified = ensureSlug(cand);
      if (slugified) return slugified;
    }
    return `post-${id}`;
  })();

  return {
    id,
    slug: derivedSlug,
    title: attrs.title,
    html: (() => {
      let extracted = '';
      const c = attrs.content;
      if (typeof c === 'string') extracted = c;
      else if (c && typeof c === 'object') {
        if (typeof c.html === 'string') extracted = c.html;
        else if (typeof c.data === 'string') extracted = c.data;
        else if (typeof c.value === 'string') extracted = c.value;
      }
      if (!extracted) {
        // try various direct fields
        extracted =
          attrs.html ??
          attrs.body ??
          attrs.content_html ??
          attrs.contentHtml ??
          attrs.contents ??
          attrs.markdown ??
          attrs.description ??
          '';
      }
      if (Array.isArray(attrs.blocks)) {
        const parts: string[] = [];
        for (const blk of attrs.blocks) {
          if (typeof blk === 'string') parts.push(blk);
          else if (blk) {
            if (typeof blk.html === 'string') parts.push(blk.html);
            else if (typeof blk.body === 'string') parts.push(blk.body);
            else if (typeof blk.content === 'string') parts.push(blk.content);
            else if (typeof blk.text === 'string') parts.push(blk.text);
            // Strapi media block 지원
            else if (blk.media || blk.image || blk.url || (blk.__component && blk.__component.includes('media'))) {
               let rawUrl: string | null = null;
               let alt = '';
               if (blk.media?.data?.attributes?.url) {
                 rawUrl = blk.media.data.attributes.url;
                 alt = blk.media.data.attributes.alternativeText || '';
               } else if (blk.media?.url) {
                 rawUrl = blk.media.url;
                 alt = blk.media.alternativeText || '';
               } else if (blk.url) {
                 rawUrl = blk.url;
               } else if (blk.image?.url) {
                 rawUrl = blk.image.url;
                 alt = blk.image.alternativeText || '';
               }
               alt = alt || blk.alt || blk.caption || '';
               if (rawUrl) {
                 const fullUrl = rawUrl.startsWith('http') ? rawUrl : `${STRAPI_URL}${rawUrl}`;
                 parts.push(`<p><img src="${fullUrl}" alt="${alt}" /></p>`);
               } else if (process.env.NODE_ENV !== 'production') {
                 console.warn('[toGhostLikePost] Media block missing URL:', JSON.stringify(blk).slice(0,300));
               }
             }
          }
        }
        const mediaHtml = parts.join('\n');
        // If no prior HTML, use mediaHtml; otherwise append so images are not lost.
        extracted = extracted ? `${extracted}\n${mediaHtml}` : mediaHtml;
      }
      // If still no HTML tags, attempt Markdown ➜ HTML conversion first
      if (extracted && !/<[a-z][\s\S]*>/i.test(extracted)) {
        try {
          extracted = marked.parse(extracted) as string;
        } catch (_) {
          // fallback: basic newline=><br>
          extracted = extracted
            .split(/\n{2,}/)
            .map(p => `<p>${p.replace(/\n/g, '<br />')}</p>`)
            .join('\n');
        }
      }
      if (!extracted && process.env.NODE_ENV !== 'production') {
        console.warn('[toGhostLikePost] No html for id', id, 'keys', Object.keys(attrs));
      }
      return extracted;
    })(),
    feature_image: (() => {
      const url =
        attrs.cover?.data?.attributes?.url ??
        attrs.cover_url ??
        attrs.cover?.url ??
        null;
      if (!url) return null;
      return url.startsWith('http') ? url : `${STRAPI_URL}${url}`;
    })(),
    excerpt: attrs.excerpt ?? attrs.description ?? '',
    tags: (() => {
      const arr = (attrs.tags?.data ?? attrs.tags ?? []).map(toGhostLikeTag);
      if (arr.length === 0) {
        const catsSrc = attrs.categories ?? attrs.category;
        if (catsSrc) {
          const cats = catsSrc?.data ?? catsSrc;
          if (Array.isArray(cats)) {
            cats.forEach((c:any)=>{ if(c) arr.push(toGhostLikeTag(c)); });
          } else {
            arr.push(toGhostLikeTag(cats));
          }
        }
      }
      return arr;
    })(),
    published_at: attrs.publishedAt ?? attrs.published_at,
    primary_author: attrs.author?.data ? toGhostLikeAuthor(attrs.author.data) : null,
  };
};

export async function getPosts({ start = 0, limit = 10 } = {}) {
  let lastFetchedIso = await getString('posts:lastFetched');
  // Build REST query string
  const listKey = `posts:list:${start}:${limit}`;
  const lastFetchedKey = 'posts:lastFetched';
  const cached = await getCachedJson<any[]>(listKey);
  if (cached) {
     if (process.env.NODE_ENV !== 'production') console.log('[getPosts] cache hit', listKey, 'len', cached.length);
     // 30초 이내에 이미 체크했다면 바로 반환
     if (lastFetchedIso) {
       const ageMs = Date.now() - new Date(lastFetchedIso).getTime();
       if (ageMs < 30 * 1000) {
         return cached;
       }
     }
     // incremental update check
    lastFetchedIso = await getString(lastFetchedKey);
    let newestIso = lastFetchedIso;
    try {
      if (lastFetchedIso) {
        const incrQuery = qs.stringify({
          filters: { updatedAt: { $gt: lastFetchedIso } },
          populate: '*',
          sort: 'updatedAt:asc',
        }, { encodeValuesOnly: true });
        const incrRes = await fetch(`${STRAPI_URL}/api/articles?${incrQuery}`, { headers: { ...AUTH_HEADERS } });
        if (incrRes.ok) {
          const incrJson = await incrRes.json();
          const changed = incrJson.data ?? [];
          if (changed.length) {
            // map and merge
            const mapped = changed.map(toGhostLikePost);
            const byId = new Map<any, any>(cached.map((p:any) => [p.id, p]));
            mapped.forEach((p: any) => byId.set(p.id, p));
            const merged = Array.from(byId.values()).sort((a:any,b:any)=>new Date(b.published_at||b.publishedAt).getTime()-new Date(a.published_at||a.publishedAt).getTime()).slice(0, limit);
            const redis = getRedis();
            await redis.set(listKey, JSON.stringify(dedupeBySlug(merged)));
            newestIso = changed[changed.length-1].attributes?.updatedAt || newestIso;
            if (newestIso) await setString(lastFetchedKey, newestIso);
            return dedupeBySlug(merged);
          }
        }
      }
    } catch(e){ console.warn('[getPosts] incremental update failed', (e as Error).message);}  
  }

  if (process.env.NODE_ENV !== 'production') {
    console.log('[getPosts] STRAPI_URL', STRAPI_URL);
  }
  const queryString = qs.stringify(
    {
      pagination: { start, limit },
      sort: 'publishedAt:desc',
    },
    { encodeValuesOnly: true }
  );

  let res = await fetch(`${STRAPI_URL}${FULL_ARTICLE_ENDPOINT}?${queryString}`, {
    headers: { ...AUTH_HEADERS },
  });

  if (!res.ok) {
    const status = res.status;
    let body = '';
    try { body = await res.text(); } catch {}
    throw new Error(`Strapi full endpoint error ${status}: ${body.slice(0,300)}`);
  }

  const json = await res.json();
  const items = Array.isArray(json) ? json : (json.data ?? []);
  if (items.length === 0) {
    console.log('[getPosts] raw json', JSON.stringify(json).slice(0,500));
  }
// 미디어 보강
for (const item of items) {
  const blocksArr = item.attributes?.blocks ?? item.blocks;
  if (Array.isArray(blocksArr)) {
    await enrichBlocksWithMedia(blocksArr);
  }
}
const normalized = dedupeBySlug(items.map(toGhostLikePost));
  const redis = getRedis();
  await redis.set(listKey, JSON.stringify(normalized));
  // record newest updatedAt
  const maxUpdated = items.reduce((max:string, it:any)=> {
    const u = it.attributes?.updatedAt || it.updatedAt || '';
    return u > max ? u : max;
  }, lastFetchedIso || '');
  if (maxUpdated) await setString(lastFetchedKey, maxUpdated);


  console.log('[getPosts] total:', items.length);   // ← 추가
  return normalized;
}

export async function getTags(limit: number | 'all' = 'all') {
  const queryObj: any = { sort: 'name:asc' };
  if (limit !== 'all') {
    queryObj.pagination = { limit };
  }
  const queryString = qs.stringify(queryObj, { encodeValuesOnly: true });
  const res = await fetch(`${STRAPI_URL}/api/tags?${queryString}`, {
    headers: {
      ...AUTH_HEADERS,
    },
    next: { revalidate: 300 },
  });
  if (res.status === 404) {
    // Tags collection not found – return empty list instead of crashing the page
    return [];
  }
  if (!res.ok) throw new Error(`Strapi REST error: ${res.status}`);
  const json = await res.json();
  return (json.data ?? []).map((item: any) => ({
    id: item.id,
    name: item.attributes?.name,
    slug: item.attributes?.slug,
    description: item.attributes?.description ?? null,
  }));
}

// ────────────────────────────
// Helper: fetch single upload file info, with in-memory cache
// ────────────────────────────
const fileCache = new Map<number, any>();
async function getStrapiFile(id: number) {
  if (fileCache.has(id)) return fileCache.get(id);
  const res = await fetch(`${STRAPI_URL}/api/upload/files/${id}`, { headers: AUTH_HEADERS });
  if (!res.ok) throw new Error(`Strapi file ${id} error ${res.status}`);
  const json = await res.json();
  fileCache.set(id, json);
  return json;
}

// Walk blocks array and, for media blocks with missing .data, load the file info
async function enrichBlocksWithMedia(blocks: any[]): Promise<void> {
  const promises: Promise<void>[] = [];
  if (process.env.NODE_ENV !== 'production') {
    console.log('[enrichBlocksWithMedia] blocks length', blocks.length);
  }
  for (const blk of blocks) {
    if (!blk) continue;
    if (process.env.NODE_ENV !== 'production' && blk.__component?.includes('media')) {
      console.log('[enrichBlocksWithMedia] Media block structure:', JSON.stringify(blk).slice(0,400));
    }
    // case 1: media relation present but missing data
    if (blk.media && !blk.media.data) {
      const mediaId = typeof blk.media === 'number' ? blk.media : blk.media?.id;
      if (mediaId) {
        promises.push(
          getStrapiFile(mediaId).then((fileInfo) => {
            blk.media = {
              data: { attributes: { url: fileInfo.url, alternativeText: fileInfo.alternativeText } },
            };
          }).catch((err)=>{
             console.warn(`[enrichBlocksWithMedia] Failed to load media ${mediaId}:`, err.message);
           })
        );
      }
    }
    // case 2: entire block is just the file id (Strapi returns only id)
    else if (!blk.media && blk.__component?.includes('media') && blk.id) {
      const mediaId = blk.id;
      promises.push(
        getStrapiFile(mediaId).then((fileInfo) => {
          blk.media = {
            data: { attributes: { url: fileInfo.url, alternativeText: fileInfo.alternativeText } },
          };
        }).catch((err)=>{
          console.warn(`[enrichBlocksWithMedia] Failed to load media ${mediaId}:`, err.message);
        })
      );
    }
  }
  await Promise.all(promises);
}

export async function getPostBySlug(slug: string) {
  // ────────────────────────────
  // 1) Try GraphQL deep-populate first (if plugin enabled)
  // ────────────────────────────
  try {
    const gqlData: any = await queryStrapiGraphQL(
      `query ArticleBySlug($slug: String!) {
        articles(filters: { slug: { eq: $slug } }) {
          data {
            id
            attributes {
              title
              slug
              publishedAt
              updatedAt
              blocks {
                __typename
                ... on ComponentSharedMedia {
                  id
                  caption
                  alt
                  media { data { attributes { url alternativeText } } }
                }
                ... on ComponentSharedRichText { id body }
              }
              cover { data { attributes { url } } }
            }
          }
        }
      }`,
      { slug }
    );
    const gqlItem = gqlData?.articles?.data?.[0];
    if (gqlItem) {
      if (process.env.NODE_ENV !== 'production') console.log('[getPostBySlug] resolved via GraphQL');
      return toGhostLikePost(gqlItem);
    }
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('[getPostBySlug] GraphQL failed – fallback to REST:', (e as any)?.message || e);
    }
  }

  // ────────────────────────────
  // 2) REST fallback
  // ────────────────────────────

  // 2-a) If slug is of the form "post-<id>", fetch directly by ID
  const idMatch = slug.match(/^post-(\d+)$/);
  if (idMatch) {
    const directId = idMatch[1];
    const resById = await fetch(`${STRAPI_URL}/api/articles/${directId}?populate=*`, { headers: AUTH_HEADERS });
    if (resById.ok) {
      const byIdJson = await resById.json();
      if (byIdJson.data) return toGhostLikePost(byIdJson.data);
    }
    // else fall through to slug query
  }

  // 2) 커스텀 full 엔드포인트 우선 시도
  const fullQuery = qs.stringify({ filters: { slug: { $eq: slug } } }, { encodeValuesOnly: true });
  let resFull = await fetch(`${STRAPI_URL}${FULL_ARTICLE_ENDPOINT}?${fullQuery}`, { headers: AUTH_HEADERS });
  if (resFull.ok) {
    const arrJson = await resFull.json();
    const itemFull: any = Array.isArray(arrJson) ? arrJson[0] : arrJson.data?.[0];
    if (itemFull) {
      if (process.env.NODE_ENV !== 'production') console.log('[getPostBySlug] resolved via /full');
      return toGhostLikePost(itemFull);
    }
  }
  // 2-b) fallback – 기존 REST deep populate
  const deepUrl = `${STRAPI_URL}/api/articles?filters[slug][$eq]=${encodeURIComponent(slug)}&populate=deep,3`;
  let res = await fetch(deepUrl, { headers: AUTH_HEADERS });
  if (!res.ok || (await res.clone().json()).data?.length === 0) {
    // fallback to nested populate object
    const queryString = qs.stringify(
      {
        filters: { slug: { $eq: slug } },
        populate: {
          blocks: { populate: { media: '*' } },
          cover: true,
        },
      },
      { encodeValuesOnly: true }
    );
    res = await fetch(`${STRAPI_URL}/api/articles?${queryString}`, { headers: AUTH_HEADERS });
  }
  // v5에서 nested populate 문법이 잘못되면 500이 뜰 수 있으므로 한 번 더 시도
  if (!res.ok) {
    const status = res.status;
    let body = '';
    try {
      body = await res.text();
    } catch {}
    if (process.env.NODE_ENV !== 'production') {
      console.error('[Strapi REST error]', status, body.slice(0, 300));
    }
    if (status === 500) {
      // fallback to shallow populate – we'll enrich later
      const fallbackQs = qs.stringify(
        {
          filters: { slug: { $eq: slug } },
          populate: {
            blocks: { populate: { media: true } },
            cover: true,
          },
        },
        { encodeValuesOnly: true }
      );
      res = await fetch(`${STRAPI_URL}/api/articles?${fallbackQs}`, { headers: AUTH_HEADERS });
      if (!res.ok) {
        // 마지막 시도로 dot-notation populate 사용
        const dotUrl = `${STRAPI_URL}/api/articles?filters[slug][$eq]=${encodeURIComponent(slug)}&populate=blocks.media,cover`;
        res = await fetch(dotUrl, { headers: AUTH_HEADERS });
      }
    }
    if (!res.ok) throw new Error(`Strapi REST error: ${status}`);
  }

  const json = await res.json();
  const item = json.data?.[0];
  if (!item) return null;

  // 3) Enrich media blocks individually when Strapi didn't populate them
  try {
    const blocksArr = item.attributes?.blocks ?? item.blocks;
    if (Array.isArray(blocksArr)) {
      await enrichBlocksWithMedia(blocksArr);
      if (process.env.NODE_ENV !== 'production') {
        console.dir(blocksArr, { depth: 4 });
      }
    }
  } catch {}

  return toGhostLikePost(item);
}